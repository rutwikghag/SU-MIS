---
output:
  word_document: default
  html_document: default
---
# Intro to Data Science - HW 7
##### Copyright Jeffrey Stanton, Jeffrey Saltz, and Jasmina Tacheva


```{r}
# Rutwik Ghag
```


### Attribution statement: (choose only one and delete the rest)


```{r}
# 1. I did this homework by myself, with help from the book and the professor.
```

Last assignment we explored **data visualization** in R using the **ggplot2** package. This homework continues to use ggplot, but this time, with maps.  In addition, we will merge datasets using the built-in **merge( )** function, which provides a similar capability to a **JOIN in SQL** (don't worry if you do not know SQL). Many analytical strategies require joining data from different sources based on a **“key”** – a field that two datasets have in common. 

## Step 1: Load the population data

A.	Read the following JSON file, https://intro-datascience.s3.us-east-2.amazonaws.com/cities.json and store it in a variable called **pop**.

Examine the resulting pop dataframe and add comments explaining what each column contains.



```{r}
library(RCurl)
library(jsonlite)
cities_link <- 'https://intro-datascience.s3.us-east-2.amazonaws.com/cities.json'
apiOutput <- getURL(cities_link)
pop <- fromJSON(apiOutput)
#pop dataframe consists of 1000 cities ranked according to their population i.e population variation.
```

B.	Calculate the **average population** in the dataframe. Why is using mean() directly not working? Find a way to correct the data type of this variable so you can calculate the average (and then calculate the average)

Hint: use **str(pop)** or **glimpse(pop)** to help understand the dataframe


```{r}
str(pop)
mean(as.numeric(pop$population))
#We need to convert the variable to numeric to apply any arithmetic operation because the population variable is in character format.
```

C.	What is the population of the smallest city in the dataframe? Which state is it in?


```{r}
pop[which.min(pop$population),]
#From the below output, we can see that panama city, florida has the lowest population with 36877 people.
```

## Step 2: Merge the population data with the state name data

D)	Read in the state name .csv file from the URL below into a dataframe named **abbr** (for "abbreviation") – make sure to use the read_csv() function from the tidyverse package: <br>
https://intro-datascience.s3.us-east-2.amazonaws.com/statesInfo.csv



```{r}
library(tidyverse)
abbr <- read_csv("https://intro-datascience.s3.us-east-2.amazonaws.com/statesInfo.csv")

```

E)	To successfully merge the dataframe **pop** with the **abbr** dataframe, we need to identify a **column they have in common** which will serve as the **“key”** to merge on. One column both dataframes have is the **state column**. The only problem is the slight column name discrepancy – in **pop**, the column is called **“state”** and in **abbr** – **“State.”** These names need to be reconciled for the merge() function to work. Find a way to rename **abbr’s “State”** to **match** the **state column in pop**.    


```{r}
colnames(abbr)[1] = "state"
colnames(abbr)
```

F)	Merge the two dataframes (using the **‘state’ column** from both dataframes), storing the resulting dataframe in **dfNew**.


```{r}
dfNew <- merge(pop, abbr, by = 'state')
```

G)	Review the structure of **dfNew** and explain the columns (aka attributes) in that dataframe.


```{r}
str(dfNew)
#each observation has the population details, growth, rank, name of the state, city in which the state resided and an abbreviated form the state name as well.
#Some of the supposed to be numeric columns, such as growth_from_2000_to_2013, rank, population are in character state.
```

## Step 3: Visualize the data

H)	Plot points (on top of a map of the US) for **each city**. Have the **color** represent the **population**.


```{r}
library(maps)
library(ggmap)
library(mapproj)
library(ggplot2)
library(readr)

dfNew$population <- as.numeric(dfNew$population)

 map <- ggplot()
 map <- map + geom_polygon(data = dfNew, aes(x = longitude, y = latitude, group = state, fill = population/100000, size = 0.2))
 map
```

I)	Add a block comment that criticizes the resulting map. It’s not very good.


```{r}
#The states are not joined properly and it is not easy to visualize each state as we have several cities within each state.
```

## Step 4: Group by State


J)	Use group_by and summarise to make a dataframe of state-by-state population. Store the result in **dfSimple**.


```{r}
dfSimple <- dfNew %>% group_by(state)
dfSimple <- dfSimple %>% summarize(disp = sum(population))
```

K)	Name the most and least populous states in **dfSimple** and show the code you used to determine them.


```{r}
dfSimple[which.min(dfSimple$disp),] #least populous state - Vermont
dfSimple[which.max(dfSimple$disp),] #most populous state - California
```

## Step 5: Create a map of the U.S.,  with the color of the state representing the state population

L) Make sure to expand the limits correctly and that you have used **coord_map** appropriately.

```{r}
dfSimple$state <- tolower(dfSimple$state) 
colnames(dfSimple)[1] = "region"
```


```{r}
us <- map_data("state")


ggplot() + 
  geom_polygon( data=us, aes(x=long, y=lat, group=group),
                color="black", fill="lightblue" )
MergedStates <- inner_join(us, dfSimple, by = "region")
map <- ggplot()
map <- map + geom_polygon( data=MergedStates, 
          aes(x=long, y=lat, group=group, fill = disp/1000000), 
          color="white", size = 0.2) 
map
```
